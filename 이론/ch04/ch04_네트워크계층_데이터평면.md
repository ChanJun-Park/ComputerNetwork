# Ch04 네트워크 계층 : 데이터 평면

4장에서의 목표 : 네트워크 계층에서 일어나는 일들과 원리를 알아본다.

- forwarding, routing
- how a router works
- broadcast, multicast

## 4.1 네트워크 계층 개요

![1](image/1.png)

네트워크 계층(Network Layer)는 호스트 간에 트랜스포트 계층 세크먼트를 송수신하는 서비스를 제공한다. sender host는 상위 트랜스포트 계층 세그먼트에 네트워크 계층 헤더를 붙이고, 캡슐화하여 데이터그램(Datagram, 네트워크 계층 패킷)을 생성하고, 전달한다. receiver host는 도착한 Datagram에서 트랜스포트 세그먼트를 추출하여, 상위 트랜스포트 계층에 전달한다.

네트워크 계층은 end-system 뿐만 아니라, 네트워크 코어에 존재하는 라우터 장비가 관여된 시스템이다. 라우터에는 3계층(네트워크 계층)까지 존재하고, 트랜스포트 계층이나, 어플리케이션 계층은 존재하지 않는다.

### 4.1.1 포워딩과 라우팅 : 데이터 평면과 제어 평면

라우터에서는 2가지 중요한 기능이 있는데, 포워딩(forwarding)과 라우팅(routing)이다.

**포워딩(forwarding)** 은 라우터의 입력포트로 들어온 패킷을 목적지로 보낼 수 있도록 적절한 라우터 출력포트로 보내는 작업이다. 라우터에는 포워딩 테이블(forwarding table)을 관리한다. 데이터그램 헤더에 설정된 수신자의 주소가 이 포워딩 테이블의 인덱스로 사용된다. 해당 인덱스에 대응하는 entry에는 그 패킷이 이동해야할 라우터의 외부 링크 인터페이스를 나타낸다. 포워딩은 주로 나노초(ns) 단위로 수행되며 하드웨어를 통해서 수행된다. 포워딩은 네트워크 계층의 데이터 평면에서 수행된다.

**라우팅(routing)** 은 송신자에서 수신자로 데이터 그램이 이동할 경로를 결정하는 알고리즘이다. 라우팅 알고리즘은 각 라우터의 포워딩 테이블을 적절히 결정한다. 이 때 전통적인 방법으로 라우터간 라우팅 프로토콜(routing protocol)을 이용하여 서로 소통하면서 포워딩 테이블을 구성할 수 있다. 다른 방법으로는 각 라우터에 연결되어 있는 원격 네트워크가 라우터의 포워딩 테이블을 구성할 수 있다(SDN). 라우팅 알고리즘은 밀리초(ms)에서 초(s)단위로 수행되며, 소프트웨어를 통해서 수행된다. 라우티은 네트워크 계층의 제어 평면에서 수행된다.

### 4.1.2 네트워크 서비스 모델

네트워크 서비스 모델은 송수신 호스트간 패킷 전송 특성을 정의한다. 네트워크 계층에서 제공할 수 있는 서비스들에는 어떤것들이 있을까?

- 패킷 전송을 보장 (보장된 전송)
- 패킷이 특정 시간 이내로 전송될 것을 보장 (지연 제한 이내의 보장된 전달)
- 여러 패킷이 전송될 때, 순서대로 전송될 것을 보장 (순서화 패킷 전달)
- 송신과 수신 호스트 사이에 특정한 비스 속도의 전송 링크를 애뮬레이트 (최소 대역폭 보장)

인터넷 네트워크 계층은 최선형 전달 서비스(best-effort) 방식을 사용한다. 이는 패킷이 수신자로 전달되는 것을 보장하지 않는다(패킷 손실 가능). 또한 여러 패킷을 전송할 경우, 패킷의 순서가 지켜지지 않을 수 있다. 보당된 최소 대역폭 또한 없다. 그러나 최선형 전달 서비스만으로도 충분히 좋은 네트워크 계층 서비스가 가능하다는 것이 알려져있다.

## 4.2 Virtual Circuit and Datagram networks

트랜스포트 계층의 TCP와 UDP 처럼 네트워크 계층에서도 데이터를 전송할때 호스트간의 연결(Connection) 여부에 따라서 Datagram Network, Virtual Connection Network로 나눌 수 있다.

### Virtual Connection Network

![3](image/3.png)

TCP 처럼 두 호스트가 데이터를 송수신하기 전에 미리 어떤 연결(Connection)을 설정하는 과정이 있다. Virtual Connection은 연결과정에서 두 호스트가 데이터를 송수신하는 경로(path), 이 경로 상에 존재하는 라우터들(Router)를 확정한다. 데이터를 송수신하기 전에 연결과정을 거쳐야 하는 오버헤드가 존재하지만, 한번 연결이 되면 경로상에 존재하는 라우터 자원들이 하나의 연결에 할당되어 predictable한 서비스가 가능하며, 패킷 전송 순서가 일정하게 유지되는 등의 장점이 있다. VC 상의 패킷은 목적지 주소 대신 VC number라는 것을 관리한다. 이 VC number에 대응하는 출력포트를 포워딩 테이블로 관리한다. 또한 각 라우터에는 입력 포트와 출력 포트에 연결에 대한 `state`를 관리한다.

![4](image/4.png)

전화 시스템에서 발달된 형태이다. 호스트 사이의 네트워크에 많은 기능을 구현하고, 호스트 시스템은 간단한 기능만을 수행한다. (**dumb endsystem**)

### Datagram Networks

![5](image/5.png)

패킷 헤더에 설정된 목적지의 주소를 가지고 라우터에서 나갈 출력 포트를 결정한다. 두 호스트가 통신하기 전에 연결과정이 필요하지 않다.

호스트 사이의 데이터 송수신간 많은 부분을 호스트 시스템에서 구현한다. (**smart endsystem**)

## 4.3 라우터 내부 구조

![6](image/6.png)

- **입력 포트** : 입력포트는 다음과 같은 3가지 부분으로 구성되어 있다. 입력포트의 반대편 라우터에서부터 연결되는 링크 신호 송수신에 사용되는 물리 계층 프로토콜(phsical layer protocol), 중간에 링크 계층 프로토콜(link layer protocol)이 있다. 가장 중요한 부분은 맨 오른쪽에 빨간색 상자로 표현된다. 이곳에서는 어떤 출력포트로 패킷을 전송할 것인지를 **검색** 하는 네트워크 계층 구성요소로 되어 있다. 이곳에서 포워딩 테이블을 참조하여 도착된 패킷이 스위칭 구조를 통해 전달되는 라우팅 출력 포트를 결정한다. 제어 패킷은 입력포트에서 라우팅 프로세서로 전달된다.
- **스위치 구조** : 스위칭 구조는 라우터의 입력포트와 출력 포트를 연결한다.
- **출력 포트** : 출력포트에서는 입력포트로부터 받은 데이터그램을 저장할 네트워크 계층 구성요소, 링크 계층, 물리 계층 구성요소가 존재한다. 링크가 양방향일 때, 출력포트는 일반적으로 동일한 링크의 입력포트와 한 쌍을 이룬다.
- **라우팅 프로세서** : 제어 평면 기능을 수행한다. 라우터들과 라우팅 프로토콜을 수행하여 포워딩 테이블을 수정한다. 또는 SDN의 경우 원격 컨트롤러에서 계산된 포워딩 테이블 항목을 수신하고 라우터의 입력 포트에 이러한 항목을 설치한다. 또 네트워크 관리 기능을 수행한다.

### 4.3.1 입력 포트 처리 및 목적지 기반 전달

![7](image/7.png)

### 포워딩 테이블

포워딩이란 라우터의 입력포트로 들어온 패킷을 적절한 출력포트로 전달하는 과정이라고 했다. 이 과정에서 포워딩 테이블(forwarding table)을 이용한다고도 언급했다.

포워딩 테이블의 인덱스는 어떻게 결정될까? 일반적으로 사용하는 IPv4 주소는 32bit로 구성되어있다. 가능한 모든 ip에 대해서 엔트리를 생성하려면 40억개 이상의 엔트리가 필요하기 때문에 현실적으로 불가능하다. 대신 특정 ip 주소 범위를 하나의 entry에 대응시킨다.

#### Longest prefix matching

입력포트로 들어온 패킷의 주소를 포워딩 테이블과 매칭시켜 비교할 때 Longest prefix matching 기법을 사용한다. ip 주소의 prefix 부분을 테이블 인덱스와 비교하여 가장 길게 match되는 인덱스의 엔트리를 사용한다.




### 스위치 구조 (Switching fabric)

라우터 내부에서는 어떻게 입력포트로 들어온 패킷을 출력포트로 전송하는가? 다음과 같은 3가지 방법이 존재한다.

- 메모리 구조 (memory)
- 버스 구조 (bus)
- 크로스바 구조 (interconnection cross bar)

#### 메모리 구조

입력 포트에서 패킷이 들어오면 라우터 프로세서에 인터럽트 방식으로 이를 알리고 시스템 메모리에 패킷을 저장한다. 출력 포트는 시스템 메모리에 저장되어 있는 패킷을 출력 포트로 저장한다.

#### 버스 구조

입력 포트에서 패킷이 들어오면 버스를 통해서 바로 출력 포트로 전송한다. 메모리 구조, 버스 구조에서는 한번에 하나의 패킷이 출력포트로 이동할 수 있다.

#### 크로스바 구조

입력포트에서 나오는 버스들과 출력포트로 들어가는 버스들을 서로 연결(interconnection)하여 적절한 상황에서 각 입력포트의 패킷이 각각의 출력 포트로 동시에 전송될 수 있게 하였다.

#### 스위치 구조의 성능

스위치 구조의 성능은 입력포트로 들어온 패킷을 얼마나 빨리 출력 포트로 전송하는 가에 대한 척도이다. 스위치 구조 성능은 보통 입력 포트 성능의 배수 형태로 나타나야 한다. N개의 입력포트가 있을 때, 스위치 구조의 성능은 입력포트 성능의 N배가 적절하다.

### 입력 포트에서의 큐잉

입력포트가 총 N개가 있고, 스위치 구조는 크로스바 형태라고 가정하자. 여기서 스위치 구조의 성능은 하나의 입력포트 성능의 N배가 아니라고 하자.

어느 한 시점에서 두 개의 입력포트가 동일한 하나의 출력 포트로 패킷을 전달한다고 가정해보자. 두 개의 입력포트 중 한 입력포트의 패킷은 다른 입력포트의 패킷이 모두 출력 포트로 전송될 때까지(다음 시간 단위까지) 대기해야 한다. 또한 대기해야 하는 패킷 뒤에 있는 패킷이 다음 시점에서는 현재 대기하고 있는 패킷이 없다면 아무런 경쟁없이 바로 출력포트로 전송될 수 있는 패킷일 때 큐잉이 일어날 수 있다. 이러한 큐잉을 **head of line**이라고 한다.

### 출력 포트에서의 큐잉

이번에는 스위치 구조의 성능이 입력 포트 성능의 N배라고 하자. 이런 경우에도 출력 포트에서는 큐잉이 발생할 수 있다. N개의 모든 입력포트에서 동일한 출력 포트로 패킷을 전달하는 경우를 생각해보자. 한 시간단위에서 출력 포트는 하나의 패킷만을 전송할 수 있다. 나머지 N-1개의 패킷은 출력 포트의 버퍼에 저장되게 된다.

출력 포트 버퍼에서 어느 패킷이 먼저 전송될 것인가에 대한 큐칙은 보통 FCFS(또는 FIFO으로 표현) 방식으로 전달되며, 우선순위 방식, 라운드 로빈 방식 등 다른 방법들도 사용될 수 있다.

## IP

IP에서의 데이터그램(Data gram) 구조.

- ip version
- length
- 8bit 무언가
- 16bit 무언가
- 16bit index, flag, offset
- 16bit 무언가
- 16bit 무언가
- 16bit checksum
- 32bit 목적지 ip 주소
- 32bit 송신지 ip 주소

### 데이터 그램 파편(fragment)과 재결합(reassembly)

라우터와 라우터를 연결하는 링크들은 다양한 링크 프로토콜을 사용할 수 있다. 이러한 링크의 종류에 따라서 한번에 보낼 수 있는 데이터그램 사이즈가 제한되는데 이를 MTU(Maximum Transmission Unit)라고 한다. 한 라우터에서 데이터 그램을 전송하고자 할때, 사용할 링크의 MTT보다 데이터 그램 크기가 클 수 있다. 이때 데이터 그램을 여러개의 파편(fragment)로 나누어서 여러 프레임(링크 계층 패킷 용어)을 생성한 뒤 보내진다.

한번 여러개의 프레임으로 파편화된 데이터 그램은 오직 end system에서만 재조합(reassembly)된다.

그럼 어떻게 큰 데이터 그램을 조그만한 프레임들로 나누고, 다시 end system에서 복구할까? 이는 데이터 그램 헤더의 offset, flag, index 필드를 통해서 구현된다. 파편화된 데이터 그램들은 모두 같은 index 필드를 갖고 있다. flag 비트는 이 데이터 그램이 파편화 되어 있고, 이 데이터 그램 뒤에 연결되어 있는 파편이 존재함을 알려준다. offset은 해당 데이터 그램이 원래 데이터 그램에서 어느 위치에 있었는지를 알려준다.

## 자료 출처

All material copyright 1996-2012  
J.F Kurose and K.W. Ross, All Rights Reserved
