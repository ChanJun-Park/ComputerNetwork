# Ch03 Transport Layer

이 장의 목표 : 트랜스포트 계층에서 제공하는 서비스들에 대한 원리와 이 원리가 어떻게 구현되어 있는지를 안다.

## 3.1 트랜스포트 계층 서비스 및 개요

![1](image/1.png)

트랜스포트 계층의 서비스는 한마디로 양쪽의 네트워크 호스트에서 실행되는 **프로세스** 간의 **논리적 통신(Logical Communication)** 을 제공하는 것이다. 애플리케이션은 메시지를 전송하기 위해서 사용되는 물리적인 하위 구조에 상관없이 트랜스포트 계층을 사용하여 논리적인 통신을 할 수 있다.

트랜스포트 계층은 네트워크 코어가 아니라 호스트 시스템 상에서 구현된다. 트랜스포트 계층에서는 애플리케이션 계층의 프로세스에게서 다른 end system에 존재하는 프로세스로 보낼 데이터(message)를 전달받는다. 그 다음 이 message를 적당이 나눈뒤 트랜스포트 계층 헤더를 추가한다. 이 트랜스포트 계층에서의 데이터 패킷을 **세그먼트(segment)** 라고 한다. 그 다음 아래 계층인 네트워크 계층 서비스를 이용하여 수신자의 end system의 네트워크 계층으로 세그먼트를 보낸다. 수신자 호스트에 존재하는 트랜스포트 계층은 네트워크 계층으로부터 송신자가 보낸 세그먼트를 받은 뒤 이를 다시 위 계층에 존재하는 프로세스로 전달하는 역할을 한다.

애플리케이션은 트랜스포트 계층의 서비스를 이용하기 위해서 2가지 이상의 프로토콜을 사용할 수 있는데, `TCP`와 `UDP`가 대표적인 프로토콜이다.

### 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

트랜스포트 계층을 다루는 chapter에서 네트워크 계층을 언급하는 이유는 무엇일까? 그것은 트랜스포트 계층이 직접적으로 사용하는 서비스가 바로 아래 계층인 네트워크 계층의 서비스이기 때문이다.

트랜스포트 계층이 통신하는 두 호스트 상에서 동작하는 **프로세스들 간의 논리적 통신** 을 제공한다면, 네트워크 계층은 **호스트 간의 논리적 통신** 을 제공한다. 다음과 같은 비유로 이해해볼 수 있다.

![2](image/2.png)

위에서 서술했다시피 트랜스포트 계층은 바로 아래 네트워크 계층 서비스를 이용하여 데이터를 전송한다. 그렇기 때문에 트랜스포트 계층의 서비스는 네트워크 계층 서비스에 의존적일 수 밖에 없다. 그러나 모든 부분에서 의존적인 것은 아니다. 네트워크 계층에서 제공하지 않는 서비스를 트랜스포트 계층에서 더욱 강화하여 제공하는 경우도 있다. 예를 들어 TCP는 신뢰적 데이터 전송을 보장하는데, 네트워크 서비스는 데이터의 신뢰적 전송을 보장하지 않는다. 트랜스포트 계층에서 기능을 추가하여 서비스를 강화한 형태이다.

### 3.1.2 인터넷 트랜스포트 계층의 개요

인터넷 트랜스포트 계층에서 제공하는 프로토콜은 **TCP**와 **UDP**가 있다.

네트워크 계층에서의 프로토콜을 잠깐만 살펴보자. 이 계층에 존재하는 프로토콜은 IP(Internet Protocol)이다. 트랜스포트 계층으로부터 받은 세그먼트에 네트워크 계층 헤더를 붙여서 캡슐화한다. 이 계층에서 사용하는 데이터패킷 용어를 **데이터그램(datagram)** 이라고 한다. 네트워크 상에서 존재하는 라우터들은 네트워크 계층에서 붙인 헤더에만 접근할 수 있고, 또 그것에만 영향을 받는다. IP 프로토콜은 호스트들 간의 논리적 통신을 제공하는 **최선형 전달 서비스(best-effort delivery service)** 이다. IP 프로토콜은 데이터그램이 라우터들을 지나 수신자 호스트로 전달되게 하는 비신뢰적인 서비스이다. 데이터그램이 손실되지 않는지, 순서대로 전달되는지, 데이터그램의 무결성이 깨지지는 않았는지 보장하지 않는다.

이제 TCP와 UDP에 대해서 간략하게 살펴보자. 이들 프로토콜은 네트워크 계층에서 제공하는 **호스트와 호스트간의 통신**을 **프로세스와 프로세스간의 통신** 으로 확장한다. 이것을 트랜스포트 **Multiplexing** 과 **Demultiplexing** 이라고 한다. 또한 애플리케이션 메시지를 분할하고 트랜스포트 헤더를 붙일때 오류 검출 필드를 붙여 데이터 전송의 **무결성 확인** 기능을 제공하기도 한다. 위에서 언급한 2가지 기능이 UDP에서 제공하는 기능의 전부이다. UDP는 프로세스들 간의 비신뢰적이고 비연결적인 데이터 전송을 제공한다.

반면에 TCP는 데이터 전송간에 **혼잡제어**와 **흐름제어**와 같은 추가적인 기능을 제공한다. 또한 TCP는 프로세스들 간의 **신뢰적 데이터 전송기능**을 제공한다.

## 3.2 다중화와 역다중화(Multiplexing과 Demultiplexing)

![3](image/3.png)

호스트 시스템에서는 여러 개의 네트워크 프로세스가 실행될 수 있다. 각 프로세스는 네트워크 상에 연결된 다른 호스트의 프로세스와 통신하며 메시지를 주고 받는다. 목적지 호스트의 트랜스포트 계층은 네트워크 계층으로부터 받은 데이터그램을 세그먼트로 풀고, 해당 메시지를 적절한 프로세스로 전달한다. 그렇다면 트랜스포트 계층은 여러 프로세스 중 어떻게 적절한 프로세스에게 메시지를 전달하는 것일까? 반대로 한 호스트에서 동작하는 여러 프로세스에서 생성한 메시지를 어떻게 모두 다 다른 목적지로 보낼 수 있을까?

앞에서 언급한 질문 중 첫번째를 Demultiplexing, 두번째를 Multiplexing이라고 한다. 앞서 애플리케이션 계층에서 실행되는 모든 네트워크 애플리케이션에는 포트번호가 부여된다는 것을 배웠다. 사실 포트번호는 프로세스에 부여되는 것이 아니라, 이들 프로세스가 네트워크 서비스를 이용하기 위해서 생성은 소켓에 부여되는 번호이다. 호스트에서 실행되는 네트워크 프로세스가 여러 개일 수 있는 만큼, 생성되는 소켓도 여러개가 될 수 있다. 적절하게 Demultiplexing 하기 위해서는 소켓을 식별할 수 있는 유일한 식별자가 필요해진다. 트랜스포트 계층의 프로토콜(TCP, UDP)마다 소켓을 구별하기 위한 식별자를 소켓에 부여한다.

![4](image/4.png)

트랜스포트 계층에서는 메세지에 적절한 헤더 정보를 추가하는데, 목적지 프로세스 소켓의 포트번호와 출발지 프로세스 소켓의 포트번호를 추가한다. 네트워크 계층에서는 이에 추가하여 출발지와 목적지 IP 주소 정보를 헤더에 추가하여 데이터그램을 완성시킨다. 이렇게 하여 여러 프로세스로부터 받은 메세지들을 모두 적절한 목적지로 이동할 수 있도록 Multiplexing 할 수 있다.

네트워크 계층을 통해서 목적지 호스트의 네트워크로 데이터그램을 이동시키면, 목적지 호스트의 네트워크 계층은 다시 트랜스포트 계층으로 패킷을 전송한다. 트랜스포트 계층에서는 세그먼트의 헤더정보에 담긴 목적지 포트번호를 확인하여 적절한 프로세스의 소켓에 메세지를 전달한다. 이 과정이 Demultiplexing의 원리이다. 지금 서술한 Demultiplexing은 목적지 포트번호만을 확인하는 UDP 프로토콜의 과정이다. TCP 프로토콜에서는 목적지 소켓을 특정하기 위해 추가적인 정보(출발지 포트번호, 목적지 포트번호, 출발지 IP, 목적지 IP)를 확인한다.

### 비연결형 다중화와 역다중화

![5](image/5.png)

비연결형 트랜스포트 프로토콜에서는 Multiplexing과 Demultiplexing 을 위해서 세그먼트 헤더에 출발지 포트번호와 목적지 포트번호를 설정하고 확인한다. 수신자 호스트에서 세그먼트를 수신한 트랜스포트 계층은 목적지 포트번호를 보고 적절한 프로세스의 소켓에 메시지를 전달한다. 출발지 포트번호는 메시지 수신자가 다시 송신자에게 응답메시지를 보내고 싶을 경우, 출발지 포트번호를 목적지 포트번호로 설정하여 사용하기 위해서 추가된다.

그림에서 양쪽 두개의 호스트에서 가운데 호스트로 동일한 목적지 포트 번호를 설정하여 세그먼트를 전달하는 것을 볼 수 있다. 비연결형에서는 소켓을 구별하는 식별자로 목적지 포트번호만을 사용하기 때문에 이들 데이터는 모두 동일한 프로세스의 소켓으로 전달된다.

### 연결형 다중화와 역다중화

![6](image/6.png)

TCP 연결형 다중화는 좀 더 추가적인 정보를 살펴봐야한다. 프로세스가 소유하는 소켓은 다음의 4개의 튜플로 식별된다.

- 출발지 IP와 출발지 포트번호
- 목적지 IP와 목적지 포트번호

TCP 프로토콜을 사용하는 프로세스는 여러개의 연결을 수행하여 많은 소켓을 생성하여 사용할 수 있다. 트랜스포트 계층에서 Demultiplexing을 수행하기 위해서는 세그먼트 헤더에 포함된 4가지 튜플을 확인하여 적절한 프로세스 소켓에 메시지를 전달한다(초기 서버 연결 요청은 제외). 위 그림에서 B라는 IP주소를 갖는 호스트에 3개의 세그먼트가 모두 동일한 목적지 포트번호를 갖고 전송되고 있으나, 모두 다른 소켓으로 메시지가 전송되는 것을 볼 수 있다. 이는 TCP 연결에서는 소켓을 식별하기 위해 목적지 포트 번호에 더하여 추가적인 3가지 정보(목적지 IP, 출발지 IP, 출발지 포트번호)를 사용하기 때문이다.

## 3.3 비연결형 트랜스포트: UDP

UDP는 매우 간단한 기능만을 제공하는 트랜스포트 프로토콜이다. UDP는 네트워크 프로세스에서 메시지를 받아서 포트번호를 설정하여 세그먼트로 만들고 네트워크 계층으로 전달한다(Multiplexing). 목적지에서는 네트워크계층에서 받은 세그먼트를 다시 목적지 포트번호와 동일한 소켓에서 전달한다(Demultiplexing). 네트워크 애플리케이션은 거의 IP를 이용해서 통신하는 것과 같다. 네트워크 계층은 데이터그램을 best effort delivery 방식으로 전달하기 때문에 UDP 역시 best effort delivery라고 할 수 있다. 이 때문에 중간에 패킷이  손실되거나, 패킷의 순서가 바뀌어서 전달될 수도 있는 비신뢰적인 데이터 전송이다. 호스트간의 논리적 통신 서비스만을 제공하고, TCP와 같이 혼잡제어나 흐름제어와 같은 추가적인 기능을 제공하지 않는 단순한 데이터 전송이다. 또한 TCP처럼 서로 통신하기 전에 handshaking 과정이 없는 비연결형 트랜스포트이다.

UDP는 주로 영상미디어처럼 데이터의 일부가 손실되어도 큰 지장이 없는 loss tolerant 애플리케이션에 사용될 수 있고, DNS에서도 사용될 수 있는데 TCP처럼 우선 연결이 필요한 통신은 느리기 때문에 빠른 데이터 전송이 필요한 UDP가 선호된다. 그리고 네트워크의 상태를 점검하는 SNMP에서도 UDP가 사용되는데, 혼잡한 상태의 네트워크에서 자동으로 패킷전송 속도를 조절하는 TCP를 이용해서는 네트워크 상태를 진단하기 어렵기 때문이다.

TCP가 더 많은 기능을 제공함에도 UDP가 존재하는 이유는 다음과 같다.

- 애플리케이션 레벨에서 무슨 데이터를 언제 보낼지에 대해 더 정교한 제어가 가능하다.
- 통신을 하기 전 미리 연결을 하지 않는다. 통신을 하기 전 상대적으로 긴 연결과정이 없기 때문에 빠른 전송이 필요한 DNS 같은 곳에서 선호된다.
- 연결 상태를 저장하지 않는다. TCP에서는 서로 통신하기 위해 출력버퍼, 입력버퍼, 혼잡제어 조절을 위한 파라미터 등 연결상태를 저장하게 된다. UDP에서는 이러한 연결상태를 저장하지 않기 때문에 적은 오버헤드로 더 많은 연결을 할 수 있다.
- 패킷 사이즈가 줄어든다. UDP에서 추가하는 세그먼트 헤더는 8바이트인 반면 TCP에서 추가하는 세그먼트 헤더는 20바이트나 된다.

### 3.3.1 UDP 세그먼트 구조

![7](image/7.png)

UDP에서는 네트워크 프로세스로부터 받은 메시지에 16bit로 구성된 필드 4개를 붙여서 세그먼트로 만든다. 출발지 포트번호와 목적지 포트번호, UDP 세그먼트의 전체 바이트길이, checksum 비트가 그 헤더 필드들이다. 포트번호는 Multiplexing과 Demultiplexing에 사용된다. checksum 필드는 오류검출을 위해 사용된다.

### 3.3.2 UDP 체크섬

![8](image/8.png)

송신자 입장에서 UDP 체크섬 필드를 구성하는 방법은 다음과 같다. 전체 UDP 세그먼트의 데이터를 16bit 워드 단위로 모두 더하고, 그 과정에서 발생한 최상위비트 캐리는 윤회식으로 맨아래 비트에 더하며, 최종적으로 덧셈 결과에 1의 보수를 취한 결과와 같다. 이 과정은 위 그림에서 다시 확인할 수 있다. 수신자는 다시 segment의 모든 필드를 더하고 checksum 필드까지 더한다. 그 결과가 1111111111111111 과 같으면 세그먼트에 오류가 없다는 것을 확인할 수 있다.

이러한 checksum은 신뢰적 데이터 전송과는 상관이 없는 개념이다. 신뢰적 데이터 전송은 수신자에서 패킷을 잘 받았는지에 대해서 확인하는 과정이 필요하다.

UDP 체크섬 필드는 세그먼트에 오류 존재 여부만 확인해줄뿐, 오류 회복에 대해서는 아무런 조치를 취하지 않는다. UDP 프로토콜이 오류가 있는 세그먼트를 발견했을때, 해당 세그먼트를 버리거나, 아니면 소켓에서 경고를 주면서 해당 세그먼트를 전달하는 것 뿐이다.

## 3.4 신뢰성 있는 데이터 전송의 원리

신뢰성 있는 데이터 전송은 네트워크에서 가장 중요한 10가지 개념 중 하나로 생각되는 만큼 중요하며, 트랜스포트 계층뿐만 아니라 네트워크 계층이나, 링크 계층에서도 적용될 수 있는 보편적인 개념이다.

![9](image/9.png)

위 그림은 앞으로 우리가 제작할 신뢰성 있는 데이터 전송원리의 프레임워크이다. (a) 우리는 상위 계층에게 신뢰성 있는 데이터 전송 서비스를 제공하는 것이 목표이다. 그러나 하위 계층(네트워크 계층)이 제공하는 서비스가 비신뢰적인 서비스라는 점이 우리의 작업을 어렵게 하는 요소이다.

(b) 그림은 우리가 구축할 서비스가 어떤 형태의 인터페이스로 실행될 것인가를 간략하게 보여준다. 송신자와 수신자의 트랜스포트 계층에는 우리가 구현할 reliable data transfer protocol(rdt)가 존재한다. 송신자의 상위 계층에서 데이터를 전송하기 위해서는 rdt의 rdt_send() 함수를 호출하면서 수행될 수 있다. 다음으로 하위 계층의 서비스를 이용해서 수신자의 rdt에 패킷을 전송하기 위해서는 하위계층(udt)의 udt_send() 함수를 호출하면서 수행될 수 있다. 수신자쪽에서는 하위계층(udt)가 송신자쪽에서 보낸 패킷을 수신한 경우 수신자 rdt의 rdt_rcv() 함수를 호출하여 패킷을 rdt에 보낼 수 있다. 마지막으로 rdt에서 상위 계층으로 데이터를 전달하기 위해 deliver_data() 함수를 호출한다.

문제를 간단하게 하기 위해서 우리가 사용하는 하위계층은 패킷을 순서대로 전달한다고 가정한다. 또한 송신자측에서 수신자측의 한 방향으로만 데이터를 전달한다고 가정한다. 그러나 데이터가 아닌 제어 신호는 양방향으로 전달될 수 있다.

![10](image/10.png)

그리고 송신자측과 수신자측의 프로토콜 동작을 표현하기 위해서 FSM(Finite State Machine)을 사용할 것이다. state transition은 화살표로 표현하고, 특정 이벤트 발생은 선으로 표현한다. 선 위에는 발생한 이벤트가, 그 아래에는 event로 인해 state transition이 발생할때 동작하는 action들이 나타난다. &Lambda; 기호는 아무런 동작을 수행하지 않거나, 아무런 이벤트가 발생하지 않음을 의미하는 기호로 사용된다.

### 3.4.1 신뢰적인 데이터 전달 프로토콜의 구축

우리는 하위 계층에 대한 가정을 점차 늘려가면서 조금씩 rdt를 구현할 것이다.

#### reliable transfer over a reliable channel : rdt 1.0

가장 첫번째로 하위 계층의 서비스가 패킷을 손상시키지 않으며 패킷 손실도 없는 reliable한 channel임을 가정한다. 이러한 가정에서 우리가 구현하는 rdt의 송신자, 수신자의 FSM은 다음 그림과 같다.

![11](image/11.png)

reliable한 하위 채널을 사용하기 때문에 송신자가 보낸 패킷은 무조건적으로 수신자에게 도달된다.

#### reliable transfer over a channel with bit errors : rdt 2.0

다음으로 하위 채널이 제공하는 서비스가 패킷의 비트 일부를 손상(flip 등등...) 시키는 경우를 생각해보자. 일단 송신자가 보낸 패킷에 손상이 있는지 여부를 확인하기 위해서 패킷에 checksum 필드가 추가되어야 한다. 패킷에 손상이 있을때 수신자는 어떻게 error를 복구시킬까?

이에 대한 대답을 하기전에 일상생활에서 비슷한 예를 들어보자. A, B 두 사람이 통화를 하고 있고 A가 B에게 010-1234-5678이라는 전화번호를 알려주고 있는 상황이라고 가정해보자. A는 -로 구분된 숫자 그룹(패킷)을 B에게 알려준다. 만일 우리가 B라고 했을때 숫자 그룹을 잘 알아들었으면 (네~)하고 수신여부를 A에게 알려줄 수 있다. 또한 잘 못 알아들었을때 (뭐라구요?)하고 잘못된 수신을 A에게 전달하여 잘 못들은 부분을 다시 알려줄 것을 요구할 수 있다.

![12](image/12.png)

비슷한 동작을 rdt에서도 수행할 수 있다. 수신자측은 송신자가 보낸 패킷에 오류가 없는 경우 송신자에게 positive acknowledgements 신호 (ACK)를 피드백으로 보낸다. 또한 패킷에 오류가 있는 경우에는 negative acknowledgements 신호 (NAK)를 피드백으로 보낸다.

송신자쪽에서는 수신자로부터 NAK 피드백을 받으면 패킷이 손상되었다는 것을 감지하고 전에 보냈던 패킷과 동일한 패킷을 수신자에게 보낸다. 수신자로부터 ACK 피드백을 받으면 다시 상위 계층으로부터 rdt_send 호출이 일어날 때까지 대기하게 된다.

송신자는 다음 패킷을 보내기 전에 반드시 수신자로부터 ACK 신호를 받을때까지 기다려야하기 때문에 이 방식의 특징을 `stop-and-wait`라고 한다.

rdt 2.0은 잘 동작하는 것처럼 보이지만 치명적인 결함이 있다. 바로 **ACK과 NAK이 손상되었을 가능성을 고려하지 않은 것이다.**

#### rdt 2.1 : handles garbled ACK/NAKS

일단 ACK/NAK 신호가 손상되었다는 것을 확인할 수 있도록 ACK/NAK 패킷에 checksum 비트가 추가되어야한다. 그 다음 실제적으로 ACK/NAK 신호가 손상되었다면 송신자는 어떻게 대처할 수 있을까?

여러 방식이 있을 수 있지만, 송신자는 ACK/NAK 패킷에 손상이 있는 경우 단순히 전에 보낸 패킷을 재전송한다. 그러나 단순히 재전송만 이루어져서는 안된다. 수신자는 송신자에게 보낸 ACK/NAK 신호에 손상이 있었는지 알 수 없기 때문에 송신자가 다시 보낸 데이터가 전에 보낸 데이터를 다시 보낸 것인지, 아니면 새로운 패킷인건지 알 길이 없기 때문이다.

이러한 문제를 해결하기 위해서 송신자는 패킷을 전송할 때 패킷에 **순서번호(sequece number)** 를 붙여서 전송한다. 다음은 이러한 방식으로 동작하는 sender의 FSM을 나타내는 그림이다.

![13](image/13.png)

다음은 수신자 측의 FSM을 나타낸다. 수신자는 이전 번호에 대한 패킷이 송신자로부터 중복으로 들어오는 경우 수신자가 보낸 ACK 패킷이 손상되었다는 것을 감지하고 해당 패킷을 버린 다음 다시한번 ACK 패킷을 전송한다. 수신한 패킷이 손상되어 보낸 NAK 패킷이 손상된 경우 역시 송신 측에서 피드백 패킷 손상에 대한 대처가 이전 패킷을 재전송하는 것이기 때문에 잘 해결된다. 수신자는 기다리고 있던 다음 번호의 패킷을 잘 전달받은 경우에만 다른 번호의 패킷을 기다리는 상태로 전이한다.

여기서 순서번호(sequence number)는 0과 1 두가지만 사용되고 있는데, 이는 패킷을 한번에 하나씩만 보내는 특성에 의한 것이다. 송신자와 수신자가 한번에 처리하는 패킷이 단 하나이기 때문에 이 패킷이 이전 패킷인지 아닌지만 구분하면 된다. 이 후에 다루어지는 파이프라이닝 패킷 전송 기법에서는 sequence number가 여러개가 될 수 있다.

![14](image/14.png)

#### rdt 2.2 : NAK free protocol

rdt 2.1의 수신자에서 좀 더 개선할 수 있는 여지가 있다. 송신자가 보낸 패킷에 손상이 있는 경우 NAK 패킷을 보내는 것이 아니라 이전 패킷에 대한 ACK 신호를 다시 보냄으로써 해당 패킷을 재전송하도록 요구하는 것이다. 단, 이를 위해서 수신자가 보낸 ACK 패킷이 송신자의 어떤 sequence number 패킷에 대한 것인지를 확인할 수 있도록 ACK 패킷에도 sequence number를 부여해야 한다. 다음 그림은 rdt 2.2의 송신자, 수신자측 FSM이다.

![15](image/15.png)

#### rdt 3.0 : channels with errors and loss

마지막으로 하위 계층이 데이터 손상뿐만 아니라 **데이터 손실**까지도 걱정해야하는 채널임을 가정해보자. 송신자가 보낸 패킷 또는 수신자가 보낸 ACK 패킷이 중간에 손실될 수 있다. 이 경우 송신자는 패킷을 보내놓고 아무리 기다려도 수신자측으로부터 ACK 패킷을 받을 수 없다.

이 경우 송신자측에서 일정시간이 지나도 ACK 패킷을 전송받지 못한다면 이전에 보낸 패킷을 재전송하는 방법이 있다. 이 때 패킷의 전송이 단순지연 때문에 늦게 도착하여 ACK 패킷 도달이 일정 시간 이상 늦어진 경우에도 재전송을 하게된다. 그러나 이같은 중복전송 문제는 앞서 도입한 sequnce number를 통해서 해결할 수 있다.

여기서 필요한 것은 송신자측이 기다리는 일정시간을 결정하는 것과 일정 시간이 지나면 interrupt 할 수 있도록 하는 count timer를 도입하는 것이다. 다음 그림은 rdt 3.0 에서 sender의 FSM이다.

![16](image/16.png)

그림에서 보면 송신자측은 자신의 보낸 특정 sequence number 패킷에 대한 ACK신호가 돌아오지 않는 경우에는 돌아올때까지 기다리다가 timeout 되면 다시 재전송을 하고 timer를 시작한다. 또한 흥미로운 것은 자신이 보낸 sequence number 패킷과는 다른 sequence number의 ACK 신호가 돌아오는 경우 아무 action도 취하지 않는 것이다. 이 경우 수신자 측에서 패킷 손상을 감지하여 이전 패킷에 대한 ACK 신호를 보낸것으로 자연스럽게 timeout이 되어 손상되었던 패킷을 재전송하도록 한다.

다음 그림은 rdt 3.0에서의 여러가지 시나리오를 보여준다.

![17](image/17.png)
![18](image/18.png)

### 3.4.2 파이프라인된 신뢰적 데이터 전송 프로토콜

우리가 구현한 rdt 3.0 프로토콜은 이제 기능적으로 잘 동작한다. 그러나 이 rdt 3.0 은 성능적으로 너무 구리(stink)다. 이러한 악취의 원인은 우리의 rdt가 기본적을 **stop-and-wait** 방식으로 동작하기 때문이다. 다음 그림을 보자.

![19](image/19.png)

송신자에서 수신자까지 간단하게 1Gbps 성능을 갖는 링크로 연결되어 있다고 해보자. 이 둘간의 거리가 상당히 멀어서 패킷이 링크를 타고 전송되는 시간이 15ms이다(RTT는 30ms). 또한 전체 8000 bit 크기의 패킷을 전송하는 상황이고, 수신자는 패킷을 모두 다 받자마자 매우 작은 ACK 패킷을 보낸다고 가정하자.

이때 송신자가 패킷을 보내고 다음 패킷을 보낼 수 있을 때까지의 시간에 비해, 실제로 패킷을 보내는 데 사용하는 시간의 비율(**사용율, Utilization**)은 0.00027 밖에 되질 않는다. 또한 1 Gbps의 성능을 가진 링크를 통해서 고작 266 Kbps의 throuput을 보이고있는 기가막힌 상황이다.

이러한 문제를 해결하기 위해서 우리는 한번에 하나의 패킷만 보내는 것이 아니라, 한번에 여러 패킷을 동시에 보내는 **파이프라이닝(Pipe lining)** 기법을 도입할 수 있다.

![20](image/20.png)

파이프 라이닝 기법을 도입하기 위해서 기존의 rdt 3.0 에서 추가되어야 하는 것들을 알아보자.

- sequence number가 여러 개가 되어야 한다. 기존의 rdt 3.0에서는 한번에 보내는 패킷이 단 하나였기 때문에 sequence number는 이전 패킷인지 아닌지만 구분할 수 있는 0, 1 두 가지였다. 그러나 이번에는 여러개의 패킷이 동시에 보내질 수 있기 때문에 이들을 구분할 수 있는 여러개의 sequence number가 필요해진다. 패킷에 부여할 순서번호의 범위는 보통 세그먼트의 특정 헤더 필드에 정해져있다. 이 필드가 만약 k bit로 구성되어 있다면 부여할 수 있는 순서번호는 [0, 2^k]가 된다.
- 송신자와 수신자에서 패킷에 대한 버퍼링이 필요해진다.

![21](image/21.png)

위 그림을 보면 파이프라이닝 기법을 도입하여 한번에 3개의 패킷을 보내고 있다. 이 때 송신자의 Utilization이 3배 증가하는 성능 향상을 확인할 수 있다. 이러한 파이프라이닝 기법은 2종류(Go-Back-N, Selective Repeat)가 있다.

### 3.4.3 Go-Back-N (GBN)

[GBN 애니메이션](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/go-back-n-protocol/index.html)

Go-Back-N 기법은 송신자가 파이프라이닝으로 여러개의 패킷을 보내고 수신자가 일부 패킷을 받지 못한 경우(또는 ACK 패킷이 손상된 경우), 해당 패킷부터 일정 개수의 패킷을 모두 재전송하는 방법이다.

![22](image/22.png)

송신자에서 패킷에 부여할 수 있는 순서번호에는 특정 이름이 부여된다. 송신자가 패킷을 보내고 나서 ACK을 기다리는 것 중 가장 오래된 것을 **base**로 가리킨다. 송신자가 아직 송신하지는 않았지만 사용할 수 있는 순서번호의 위치는 **nextseqnum**로 가리킨다.

한번에 보낼 수 있는 패킷 개수의 범위, 패킷을 송신했으나 아직 ACK 패킷을 전송받지 못한 패킷 중 가장 오래된 것으로 부터 새로 패킷을 전송할 수 있는 순서번호의 범위는 보통 N의 개수로 한정되어 있다(왜 무한으로 설정하지 않았는지는 다음에 배운다). 이를 **윈도우 크기(Window size)** 라고 한다. 수신자로부터 ACK 패킷을 받을 때마다 사용할 수 있는 순서번호의 범위가 한 칸씩 오른쪽으로 이동하는 것이 마치 창문을 이동시키는 것과 같아서 착안한 이름이다.

특정 순서번호에 부여된 이름과 윈도우 크기(N)을 통해 순서번호를 총 4개의 범위로 분류할 수 있다. [0, base-1]
범위의 초록색부분은 송신자에서 전송을 하고 수신자로부터 ACK 패킷도 받은 패킷에 대한 순서번호를 나타낸다. [base, nextseqnum - 1] 범위의 노란색은 송신자가 패킷을 전송했으나 아직 ACK 패킷을 받지 못한 부분이고, [nextseqnum, base + N - 1] 범위의 파란색은 아직 해당 패킷을 전송하지는 않았지만 상위 계층으로부터 rdt_send() 호출이 있으면 사용가능한 순서번호를 뜻한다. 하얀색은 아직까지 쓸 수 없는 번호를 뜻한다.

송신자는 한번에 최대 N개의 패킷을 동시에 보낸다. 수신자는 각 패킷을 정상적으로 수신했을 경우 각 패킷n에 대해서 ACKn 신호를 보낸다. 송신자는 수신자로부터 패킷n에 대한 ACKn 신호를 받으면 base를 n + 1로 옮기게된다.

상위계층에서 데이터를 전송할때 아직 수신자로부터 ACK 패킷을 받지 못한 것들이 N개일 때는 패킷을 전송할 수 없다. 이 경우 rdt에서는 해당 데이터를 다시 상위 계층에 반환하거나, 버퍼에 저장해두고 패킷을 전송할 수 있을 때 다시 전송할 수 있다.

만일 전송한 패킷이 중간에 손실되는 경우는 어떻게 할까? 윈도우 사이즈가 5이고, 송신자가 1,2,3,4,5 패킷을 한번에 전송했다고 가정해보자. 중간에 패킷 3이 손실되었다. 그럼 수신자는 1번 패킷을 받고 ACK1을 보낸다. 2번 패킷을 받은 다음 ACK2를 보낸다. 3번 패킷을 받길 기대하는데 4번 패킷이 들어온다. 이 경우 수신자는 패킷 순서가 잘못됨을 감지하고 3번 패킷부터 제대로 수신하지 못했다는 의미로 ACK2를 재전송한다. 나머지 4, 5번 패킷이 수신자로 들어오는 경우에도 동일하게 ACK2를 전송한다.

송신자는 ACK1, ACK2를 받은 뒤 base를 3으로 조정한다. ACK3가 들어오기를 기대하지만, ACK2만 2번 더 들어온다. 이 경우 base는 더이상 진행하지 못하고 3에 멈춰있다. 수신자로부터 ACKn 패킷을 받은 뒤부터 송신자는 ACK(n+1)에 대한 타이머를 작동시킨다. 그리고 일정시간이 지나면 timeout 되어 (n+1)번 패킷부터 전송했던 패킷을 모두 다시 재전송한다. 이 경우 송신자는 ACK3에 대한 타이머를 작동시킨뒤, 일정 시간이 지나 timeout 되면 패킷 3, 4, 5를 재전송하게 된다.

다음 그림은 지금까지 설명한 송신자의 FSM을 나타낸다. 이 그림은 변수 base와 nextseqnum, 그리고 약간의 프로그래밍 코드가 들어가있는 확장된 FSM이다. 이벤트에서 &Lambda;로 표시된 부분은 초기화를 뜻한다.

![23](image/23.png)

앞서 설명하면서 수신자는 패킷을 한번에 하나씩 처리하는 것을 은연중에 암시하였다. 수신자는 다음에 들어올 패킷의 순서번호에 대한 **기대번호(expected number)** 를 가지고 해당 패킷이 들어오면 패킷에서 데이터를 추출하여 상위 계층으로 전달한다. 그리고 기대번호를 1 증가시킨다. 만약 기대한 번호가 아닌 번호가 들어온다면 수신자는 단순히 해당 패킷을 버린다. 이러한 설계는 수신자로부터 잘못된 순서로 들어온 패킷을 저장할 버퍼라던지 기타 다른 사항들을 구현할 필요없이 간단하게 수신자 측을 구현할 수 있게 해준다. 다음은 수신자 측의 FSM에 대한 그림이다.

![24](image/24.png)

여기서 수신자의 ACK 패킷을 **cumulative acknowledgement** 라고 한다. 이런 방식의 ACK 신호는 다음과 같은 동작을 가능하게한다.

만약 송신자 측에서 1,2,3,4,5 패킷을 보내고, 수신자 측에서 모든 패킷을 수신하여 ACK 1,2,3,4,5를 돌려보냈다고 해보자. 만약 중간에 ACK 3,4 가 손실되었다면 어떻게 될까? 송신자는 ACK 1,2를 돌려받고 나서 바로 ACK 5를 받게 된다. 이때 송신자는 모든 패킷이 정상적으로 수신자에게 전송되었음을 확신할 수 있다. 왜냐하면 수신자는 한번에 하나씩 패킷을 처리하고 해당 패킷에 대한 ACK 신호를 전송하기 때문에 ACK 5가 돌아오기 위해서는 패킷 3, 4가 반드시 먼저 처리되어 ACK 3, 4를 보내야 하기 때문이다.

다음 그림은 GNB 방식의 파이프라인 동작을 나타낸 그림이다.

![25](image/25.png)

### 3.4.4 Selective Repeat (SR)

[Selective Repeat 애니메이션](https://media.pearsoncmg.com/aw/ecs_kurose_compnetwork_7/cw/content/interactiveanimations/selective-repeat-protocol/index.html)

Selective Repeat 파이프라이닝 기법은 송신자가 ACK 패킷을 받지 못한 패킷부터 다른 모든 패킷을 다시 재전송하는 GBN과는 다르게 송신자가 받지 못한 개별 ACK 패킷에 대해서 타이머를 두고, 각각을 재전송한다. 재전송이 필요하지 않는 패킷에 대해서는 재전송하지 않음으로써 네트워크에 불필요한 부하를 주지 않을 수 있다.

그러나 개별 패킷에 대한 타이머를 설정해야하고, 수신자 측에서는 수신 순서가 바뀐 패킷에 대해서 단순히 무시(GNB 방식)하는 것이 아니라 일단 각 패킷에 대해서 ACK 신호를 보내고 버퍼를 구현하여 여기에 저장시켜야한다.

![26](image/26.png)

또한 수신자 쪽에서도 수신할 수 있는 순서번호(sequence number)의 윈도우 사이즈를 설정하여 각 범위의 패킷마다 다른 동작을 수행하여야한다. 수신자가 현재 수신하기를 기대하는 패킷의 순서번호를 rcv_base라고 한다. 만약 [rcv_base, rcv_base + N - 1] 범위의 패킷이 들어온다면 해당 패킷에 대한 ACK 신호를 보내준다. rcv_base에 해당하는 패킷이 들어온 경우 패킷에서 데이터를 추출하여 바로 상위 계층으로 전달한 뒤 ACK 패킷을 전송하고 rcv_base를 한칸 이동시킨다. 또한 rcv_base 패킷보다 그 다음 패킷들이 먼저 들어올 수 있다. 이 경우 일단 해당 패킷에 대한 ACK 패킷을 전송한 뒤 패킷을 버퍼에 저장 해둔다. 그리고 후에 rcv_base 에 대한 패킷이 들어오면 rcv_base 부터 순서대로 패킷에 데이터를 추출하여 상위 계층으로 보내고 rcv_base를 아직 수신하지 못한 패킷의 순서번호 중 가장 작은 값으로 이동시킨다.

위 그림에서도 알 수 있듯이 송신자와 수신자의 window 위치는 동기화 되지 않을 수 있다. 따라서 송신자는 수신자에서 [rcv_base - N, rcv_base - 1] 에 해당하는 패킷을 재전송할 수도 있다. 이 경우 수신자는 역시 해당 패킷에도 ACK 신호를 전달할 필요가 있다.

송신자는 패킷을 보낸뒤 ACK 신호를 기다린다. 현재 기다리고 있는 send_base에 대한 ACK 신호가 아닌 다음 패킷에 대한 ACK신호가 들어온다면 그에 해당하는 패킷에만 ACK 신호를 받았음을 표시하고 send_base는 그대로 유지한다. send_base 패킷에 대한 ACK 신호를 수신하면 아직 ACK 신호를 전송 받지 못한 순서 번호 중 가장 작은 번호로 send_ base를 이동시킨다.

다음 그림은 Selective repeat에서 송신자와 수신자의 동작을 설명하는 그림이다.

![29](image/29.png)

다음 그림은 selective repeat에서 발생할 수 있는 시나리오를 나타내는 그림이다.

![27](image/27.png)

Selective Repeat은 GNB 방식에 비해서 불필요한 재전송을 줄여 네트워크 코어에 부담을 주지 않는 장점이 있다. 그러나 송신자에서 각 패킷 순서 번호에 대한 타이머를 개별적으로 구현해야 하는점, 수신자에서 윈도우와 패킷에 대한 버퍼를 관리해야 하는점 등 GNB 보다 추가적인 기능을 구현해야 하는 단점이 있다.

또한 송신자와 수신자의 윈도우가 동기화 되지 않는다는 점에서 문제가 될 수 있는 여지가 있다. 특히 윈도우 사이즈가 전체 순서번호 범위의 절반을 초과하게 될 경우 다음과 같은 딜레마가 발생할 수 있다.

![28](image/28.png)

이 시스템에서 사용할 수 있는 순서번호의 범위는 0에서 3까지 총 4개이다. 그런데 윈도우 사이즈는 3으로 설정되어 있다. 그럼 다음 2가지 상황이 혼란을 초래할 수 있다. (a) 송신자에서 처음에 패킷 0, 1, 2를 전송하고 수신자는 모든 패킷을 정상적으로 수신한뒤 ACK 0, 1, 2를 돌려보낸다. 이 후에 송신자는 다시 패킷 3, 0, 1를 전송할 수 있다. 그런데 패킷 3이 중간에 손실되어 버려서 수신자에게 패킷 0 만이 전송된다. (b) 상황은 다음과 같다. (a)와 마찬가지로 송신자가 패킷 0, 1, 2를 보낸뒤 수신자가 정상적으로 수신하고 ACK 0, 1, 2를 돌려 보낸다. 그런데 이 과정에서 ACK 0, 1, 2가 모두 손실되어버린다. 송신자는 패킷 0에 대한 ACK을 기다리다가 timeout 되어 이전의 패킷 0을 재전송하게 된다.

자 이제 혼란이 시작된다. 수신자는 패킷 0, 1, 2를 정상적으로 수신하고 ACK 0, 1, 2까지 보냈다는 점이 (a), (b)에서 동일하다. 또한 이 후에 송신자로부터 다시 들어오는 패킷에 대한 순서번호가 0이라는 것도 동일하다. 그러나 (a)의 경우 새로운 패킷에 대한 순서번호인 반면 (b)는 송신자가 재전송한 패킷에 대한 순서번호이다. 네트워크는 송신자와 수신자 사이에 존재하는 암막과 같은 역할을 한다. 수신자는 지금 들어온 0의 순서번호를 갖는 패킷이 송신자로부터 재전송된 것인지, 아니면 새로운 패킷인지 절대로 구분하지 못한다.

이러한 문제를 피하기 위해서는 송신자와 수신자가 사용할 수 있는 순서번호에 대한 윈도우 크기가, 순서번호 범위의 절반 이하여야 한다.

## 3.5 연결지향형 트랜스포트 : TCP

### 3.5.1 TCP 연결

이제 앞서 공부했던 신뢰적 데이터 전송원리를 적용하여 개발한 트랜스포트 프로토콜 TCP에 대해서 먼저 간략히 소개해보자.

- Point to Point 통신 : TCP 연결을 통해서 통신을 하면 반드시 TCP로 연결된 하나의 네트워크 프로세스와 하나의 네트워크 프로세스 간의 통신만이 가능하다.
- 연결 지향형 프로토콜(Connection-Oriented protocol) : 네트워크 상의 두 프로세스가 TCP 방식으로 통신하기 위해서는 미리 두 프로세스간의 연결(Connection)이 형성되어야 한다. TCP Connection을 생성하기 위해서는 three-way handshake라는 방식이 사용된다.
- 신뢰적인 바이트 스트림 단위 전송 : TCP에서는 애플리케이션에서 전송하는 데이터를 경계가 없는 바이트 스트림으로 간주한다. 신뢰적이라고 함은 TCP를 통해서 통신하는 네트워크 애플리케이션은 송수신 하는 데이터 바이트 스트림이 손실 및 손상이 없고 항상 올바른 순서가 유지됨을 보장한다는 의미이다.
- MSS(Maximum Segment Size) : 세그먼트의 애플리케이션 메시지에 할당할 수 있는 최대 크기
- full duplex 통신 : 하나의 TCP Connection을 통해서 송신과 수신이 동시에 이루어질 수 있다.
- flow controlled : 수신자가 받을 수 있는 속도 이상으로 데이터를 전송하지 않도록 조절할 수 있다.
- pipelined

### 3.5.3 TCP 세그먼트 구조

![30](image/30.png)

TCP 세그먼트는 보통의 경우 20바이트로 구성되어 있다. TCP 헤더의 크기 정보는 head len이라는 필드에 32bit 워드 단위로 기록된다. 다음은 TCP 세그먼트의 주요한 필드들에 대한 설명이다.

- 16bit source port #, dest port # : Multiplexing과 Demultiplexing을 위한 필드
- 32bit sequence number : pipe line된 여러개의 세그먼트를 전송할 경우, 세그먼트를 구분하는 순서번호. 순서번호는 데이터 스트림의 바이트마다 부여되며 세그먼트에 대한 순서번호는 그 세그먼트가 가지고 있는 데이터 바이트 중 첫번째 바이트의 순서번호를 의미한다.
- 32bit acknowledgement number : pipe line된 여러개의 세그먼트를 수신할 경우, 특정 세그먼트를 수신했다는 것을 구분하기 위한 확인 응답 번호. n번호의 세그먼트를 정상 수신한 경우 n+1번의 acknowledgement number를 송신자 측에 전송한다.
- 4bit head len : TCP 세그먼트 헤더 크기를 32bit 워드 단위로 나타낸것
- 6bit not used
- UAPRSF
  - U : Urgent data를 의미함. 실제로는 사용되지 않음
  - A : aknowledgement number가 유효함을 나타내는 필드
  - P : PSH. 수신자가 곧바로 수신한 데이터를 상위 계층에 전송해야함을 의미. 실제로는 사용하지 않는다.
  - R, S, F: TCP 연결 및 해제 신호 전송시 사용하는 필드
- receive window : 수신자의 수신 버퍼 크기를 체크하여 송신속도를 조절하는 flow control 시에 사용하는 필드
- checksum : 세그먼트에 손상이 있는지 없는지 체크하는 필드
- Urg Data pointer : 잘 사용하지 않음
- Options : TCP에 대한 서비스 옵션들을 설정하는 필드.

#### 순서번호와 확인 응답 번호

TCP에서 순서번호는 세그먼트 단위로 부여되는 것이 아니라 전송되는 데이터 스트림의 바이트 단위로 부여된다.

TCP에서는 전송하고자 하는 데이터 스트림을 MSS 사이즈로 나누어서 세그먼트들을 생성한다. 이 때 세그먼트의 sequence number 필드에 들어가는 순서번호는 해당 세그먼트가 표함하고 있는 데이터 바이트들 중 가장 앞쪽 바이트의 순서번호를 의미한다.

수신자쪽에서는 송신자쪽에서 보내온 데이터 바이트들을 정상적으로 수신하고 마지막 수신한 바이트의 순서번호 + 1로 acknowledgement number를 설정한다. 이는 ack num - 1 까지의 바이트들을 모두 정상 수신하고, 다음으로 ack num에 대한 바이트를 수신하기를 기대한다는 의미이다. acknowledgement number는 culmulative ack으로 동작한다. 즉 수신자가 ack num으로 n을 전송한다면, n 이전 데이터들에 대해서 모두 정상 수신함을 의미한다.

![31](image/31.png)

#### Telnet 프로토콜에서의 예시

![32](image/32.png)

Telnet은 원격 로그인을 위한 애플리케이션 프로토콜이다. TCP를 트랜스포트 프토토콜로 이용한다. 특이한점은 데이터를 송수신할 때 1바이트 크기로만 송수신한다는 것이다.

위 그림은 HostA에서 HostB 컴퓨터를 원격으로 로그인하는 시나리오를 보여준다. Host A에서 문자 C를 입력하면 HostB에서는 해당 문자가 입력되었음을 Host A의 모니터에서 확인할 수 있도록 문자 C를 다시 보낸다(echo). 주목할 점은 HostB에서 문자 C를 돌려 보낼때, 이전에 받은 문자 C에 대한 Acknowledgement number를 같이 전송한다는 것이다. 이렇게 서버와 클라이언트간 확인 응답이 데이터 세그먼트를 전송하는 과정에서 함께 전달될 수 있다. 이러한 확인 응답은 데이터 세그먼트 상에서 피기백(piggy back)되었다고 한다.

### 3.5.3 왕복시간(RTT) 예측과 타임아웃
